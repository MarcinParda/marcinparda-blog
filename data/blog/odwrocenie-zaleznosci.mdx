---
title: 'OdwrÃ³cenie zaleÅ¼noÅ›ci'
date: '2023-09-17'
tags: ['paradygmaty', 'wzorce-projektowe']
draft: false
summary: 'Ten artukuÅ‚ to tÅ‚umaczenie posta Inversion of Control autorstwa Kent C. Dodds. W artykule Kent opisuje jak odwrÃ³cenie zaleÅ¼noÅ›ci moÅ¼e pomÃ³c w tworzeniu kodu wielokrotnego uÅ¼ytku.'
authors: ['default']
---

> To jest tÅ‚umaczenie orginalnego posta [Inversion of Control](https://kentcdodds.com/blog/inversion-of-control) autorstwa [Kent C. Dodds](https://kentcdodds.com/).

**[Obejrzyj "Implement Inversion of Control" na egghead.io](https://egghead.io/lessons/egghead-implement-inversion-of-control?pl=kent-s-blog-posts-as-screencasts-eefa540c&af=5236ad)**

JeÅ›li kiedykolwiek tworzyÅ‚eÅ› kod, ktÃ³ry byÅ‚ uÅ¼ywany w wiÄ™cej niÅ¼ jednym miejscu, to prawdopodobnie znasz tÄ™ historiÄ™:

1.  Tworzysz kod wielokrotnego uÅ¼ytku (funkcjÄ™, komponent React lub React hook, itp.) I udostÄ™pniasz go (wspÃ³Å‚pracownikom lub publikujesz go jako kod Open Source).
2.  KtoÅ› podchodzi do ciebie z nowym przypadkiem uÅ¼ycia, ktÃ³rego twÃ³j kod nie _do koÅ„ca_ obsÅ‚uguje, ale mÃ³gÅ‚by z niewielkÄ… poprawkÄ….
3.  Dodajesz kolejny argument/prop/opcjÄ™ do kodu wielokrotnego uÅ¼ytku i powiÄ…zanej logiki, aby obsÅ‚ugiwaÄ‡ ten przypadek uÅ¼ycia.
4.  PowtÃ³rz kroki 2 i 3 kilka razy (lub wiele razy ğŸ˜¬).
5.  Kod wielokrotnego uÅ¼ytku jest teraz koszmarem do uÅ¼ycia i konserwacji ğŸ˜­

Co dokÅ‚adnie sprawia, Å¼e ten â€‹â€‹kod jest koszmarem do uÅ¼ycia i konserwacji? Istnieje kilka rzeczy, ktÃ³re mogÄ… byÄ‡ problemem:

1.  ğŸ˜µ **Rozmiar pakietu i/lub wydajnoÅ›Ä‡:** Jest po prostu wiÄ™cej kodu do uruchomienia przez urzÄ…dzenia, co moÅ¼e wpÅ‚ywaÄ‡ na wydajnoÅ›Ä‡ w negatywny sposÃ³b. Czasami moÅ¼e byÄ‡ na tyle Åºle, Å¼e ludzie decydujÄ… siÄ™ nawet nie rozwaÅ¼aÄ‡ uÅ¼ycia Twojego kodu ze wzglÄ™du na te problemy.
2.  ğŸ˜– **Nadmiar konserwacji:** WczeÅ›niej twÃ³j kod wielokrotnego uÅ¼ytku miaÅ‚ tylko kilka opcji i skupiaÅ‚ siÄ™ na tym, aby dobrze wykonywaÄ‡ jednÄ… rzecz, ale teraz moÅ¼e zrobiÄ‡ wiele rÃ³Å¼nych rzeczy i potrzebujesz dokumentacji dla tych funkcji. Ponadto bÄ™dziesz otrzymywaÄ‡ wiele pytaÅ„ od osÃ³b, ktÃ³re chcÄ… uÅ¼yÄ‡ go do swoich konkretnych przypadkÃ³w uÅ¼ycia, ktÃ³re mogÄ… lub nie mogÄ… dobrze odzwierciedlaÄ‡ przypadki uÅ¼ycia, ktÃ³re juÅ¼ obsÅ‚ugujesz. MoÅ¼e nawet zdarzyÄ‡ siÄ™, Å¼e dwie funkcje pozwalajÄ… na to samo, ale nieco inaczej, wiÄ™c bÄ™dziesz odpowiadaÄ‡ na pytania, ktÃ³ra jest lepsza.
3.  ğŸ› **ZÅ‚oÅ¼onoÅ›Ä‡ implementacji:** To _nigdy_ nie jest "tylko instrukcja `if`". KaÅ¼da gaÅ‚Ä…Åº logiki w Twoim kodzie Å‚Ä…czy siÄ™ z istniejÄ…cymi gaÅ‚Ä™ziami logiki. Faktycznie istniejÄ… sytuacje, w ktÃ³rych moÅ¼esz obsÅ‚ugiwaÄ‡ kombinacjÄ™ argumentÃ³w/opcji/propsÃ³w, ktÃ³rych nikt nie uÅ¼ywa, ale musisz upewniÄ‡ siÄ™, Å¼e ich nie zepsujesz, gdy dodajesz nowe funkcje, poniewaÅ¼ nie wiesz, czy ktoÅ› uÅ¼ywa tej kombinacji czy nie.
4.  ğŸ˜• **ZÅ‚oÅ¼onoÅ›Ä‡ API:** KaÅ¼dy nowy argument/opcja/prop, ktÃ³ry dodajesz do kodu wielokrotnego uÅ¼ytku, sprawia, Å¼e â€‹â€‹jest trudniejszy do uÅ¼ycia, poniewaÅ¼ masz teraz ogromnÄ… README/dokumentacjÄ™, ktÃ³ra dokumentuje wszystkie dostÄ™pne funkcje, a ludzie muszÄ… nauczyÄ‡ siÄ™ wszystkiego, co jest dostÄ™pne, aby uÅ¼ywaÄ‡ ich efektywnie. Jest mniej przyjemnoÅ›ci z korzystania z kodu, poniewaÅ¼ czÄ™sto zÅ‚oÅ¼onoÅ›Ä‡ twojego API trafia do kodu dewelopera aplikacji w sposÃ³b, ktÃ³ry sprawia, Å¼e â€‹â€‹ich kod jest bardziej zÅ‚oÅ¼ony.

WiÄ™c teraz wszyscy sÄ… smutni z tego powodu. MoÅ¼na powiedzieÄ‡, Å¼e dostarczanie jest najwaÅ¼niejsza, gdy tworzymy aplikacje. Ale myÅ›lÄ™, Å¼e byÅ‚oby fajnie, gdybyÅ›my mogli byÄ‡ Å›wiadomi naszych abstrakcji (czytaj [AHA Programming](/blog/aha-programming)) _i_ dostarczali nasze aplikacje. JeÅ›li istnieje coÅ›, co moÅ¼emy zrobiÄ‡, aby zredukowaÄ‡ problemy z kodem wielokrotnego uÅ¼ytku, jednoczeÅ›nie czerpiÄ…c korzyÅ›ci z tych abstrakcji.

## [WstÄ™p: OdwrÃ³cenie zaleÅ¼noÅ›ci](#wstep-odwrocenie-zaleznosci)

JednÄ… z zasad, ktÃ³rej nauczyÅ‚em siÄ™, ktÃ³ra jest naprawdÄ™ skutecznym mechanizmem prostoty abstrakcji, jest "OdwrÃ³cenie zaleÅ¼noÅ›ci". Oto, co [strona Wikipedii o odwrÃ³ceniu zaleÅ¼noÅ›ci](https://en.wikipedia.org/wiki/Inversion_of_control) mÃ³wi o tym:

> ...w tradycyjnym programowaniu kod, ktÃ³ry wyraÅ¼a cel programu, wywoÅ‚uje biblioteki, aby wykonaÄ‡ zadania ogÃ³lne, ale w przypadku odwrÃ³cenia kontroli to framework wywoÅ‚uje kod lub specyficzny dla zadania.

MoÅ¼esz o tym myÅ›leÄ‡ tak: "Spraw, aby twoja abstrakcja robiÅ‚a mniej rzeczy, a osoby uÅ¼ywajÄ…cej jej robiÄ… to zamiast niej". MoÅ¼e to wydawaÄ‡ siÄ™ sprzeczne, poniewaÅ¼ czÄ™Å›ciÄ… tego, co sprawia, Å¼e â€‹â€‹abstrakcje sÄ… takie wspaniaÅ‚e, jest to, Å¼e moÅ¼emy obsÅ‚ugiwaÄ‡ wszystkie zÅ‚oÅ¼one i powtarzajÄ…ce siÄ™ zadania w ramach abstrakcji, dziÄ™ki czemu reszta naszego kodu moÅ¼e byÄ‡ "prosta", "porzÄ…dna" lub "czysta". Ale jak juÅ¼ doÅ›wiadczyliÅ›my, tradycyjne abstrakcje czasami tak nie dziaÅ‚ajÄ….

## [Co to jest odwrÃ³cenie kontroli w kodzie?](#co-to-jest-odwrocenie-kontroli-w-kodzie)

Najpierw oto super wymyÅ›lony przykÅ‚ad:

```ts
// udawajmy Å¼e Array.prototype.filter nie istnieje
function filter(array) {
  let newArray = []
  for (let index = 0; index < array.length; index++) {
    const element = array[index]
    if (element !== null && element !== undefined) {
      newArray[newArray.length] = element
    }
  }
  return newArray
}
```

Teraz zagrajmy w typowy "cykl Å¼ycia abstrakcji", rzucajÄ…c tonÄ™ nowych powiÄ…zanych przypadkÃ³w uÅ¼ycia w tej abstrakcji i "bezmyÅ›lnie jÄ… ulepszajÄ…c", aby obsÅ‚ugiwaÄ‡ te nowe przypadki uÅ¼ycia:

```ts
// udawajmy Å¼e Array.prototype.filter nie istnieje
function filter(
  array,
  { filterNull = true, filterUndefined = true, filterZero = false, filterEmptyString = false } = {}
) {
  let newArray = []
  for (let index = 0; index < array.length; index++) {
    const element = array[index]
    if (
      (filterNull && element === null) ||
      (filterUndefined && element === undefined) ||
      (filterZero && element === 0) ||
      (filterEmptyString && element === '')
    ) {
      continue
    }

    newArray[newArray.length] = element
  }
  return newArray
}

filter([0, 1, undefined, 2, null, 3, 'four', ''])
// [0, 1, 2, 3, 'four', '']

filter([0, 1, undefined, 2, null, 3, 'four', ''], { filterNull: false })
// [0, 1, 2, null, 3, 'four', '']

filter([0, 1, undefined, 2, null, 3, 'four', ''], { filterUndefined: false })
// [0, 1, 2, undefined, 3, 'four', '']

filter([0, 1, undefined, 2, null, 3, 'four', ''], { filterZero: true })
// [1, 2, 3, 'four', '']

filter([0, 1, undefined, 2, null, 3, 'four', ''], { filterEmptyString: true })
// [0, 1, 2, 3, 'four']
```

Dobrze, wiÄ™c faktycznie potrzebujemy tylko szeÅ›ciu przypadkÃ³w uÅ¼ycia, o ktÃ³rych aplikacja siÄ™ troszczy, ale faktycznie obsÅ‚ugujemy dowolnÄ… kombinacjÄ™ tych funkcji, co daje razem 25 kombinacji (jeÅ›li dobrze policzyÅ‚em).

I to w dodatku jest prosta abstrakcja. Jestem pewien, Å¼e moÅ¼na by jÄ… uproÅ›ciÄ‡. Ale czÄ™sto, gdy wracasz do abstrakcji po tym, jak minÄ™Å‚o trochÄ™ czasu, okazuje siÄ™, Å¼e moÅ¼na jÄ… znacznie uproÅ›ciÄ‡ dla przypadkÃ³w uÅ¼ycia, ktÃ³re faktycznie obsÅ‚uguje. Niestety, gdy abstrakcja obsÅ‚uguje coÅ› (takiego jak `{filterZero: true, filterUndefined: false}`), boimy siÄ™ usunÄ…Ä‡ tÄ™ funkcjÄ™ z obawy przed zepsuciem aplikacji uÅ¼ywajÄ…cej naszej abstrakcji.

Nawet napiszemy testy dla przypadkÃ³w uÅ¼ycia, ktÃ³rych tak naprawdÄ™ jeszcze nie mamy, tylko dlatego, Å¼e nasza abstrakcja je obsÅ‚uguje i "moÅ¼e" byÄ‡ to potrzebne w przyszÅ‚oÅ›ci. A kiedy przypadki uÅ¼ycia nie sÄ… juÅ¼ potrzebne, nie usuwamy ich obsÅ‚ugi, poniewaÅ¼ po prostu zapominamy, myÅ›limy, Å¼e moÅ¼e ich potrzebowaÄ‡ w przyszÅ‚oÅ›ci, lub boimy siÄ™ dotykaÄ‡ kodu.

Dobrze, wiÄ™c teraz, rozwaÅ¼my trochÄ™ przemyÅ›lanej abstrakcji na tej funkcji i zastosujmy odwrÃ³cenie kontroli, aby obsÅ‚ugiwaÄ‡ wszystkie te przypadki uÅ¼ycia:

```ts
// udawajmy Å¼e Array.prototype.filter nie istnieje
function filter(array, filterFn) {
  let newArray = []
  for (let index = 0; index < array.length; index++) {
    const element = array[index]
    if (filterFn(element)) {
      newArray[newArray.length] = element
    }
  }
  return newArray
}

filter([0, 1, undefined, 2, null, 3, 'four', ''], (el) => el !== null && el !== undefined)
// [0, 1, 2, 3, 'four', '']

filter([0, 1, undefined, 2, null, 3, 'four', ''], (el) => el !== undefined)
// [0, 1, 2, null, 3, 'four', '']

filter([0, 1, undefined, 2, null, 3, 'four', ''], (el) => el !== null)
// [0, 1, 2, undefined, 3, 'four', '']

filter(
  [0, 1, undefined, 2, null, 3, 'four', ''],
  (el) => el !== undefined && el !== null && el !== 0
)
// [1, 2, 3, 'four', '']

filter(
  [0, 1, undefined, 2, null, 3, 'four', ''],
  (el) => el !== undefined && el !== null && el !== ''
)
// [0, 1, 2, 3, 'four']
```

Åšwietnie! To _duÅ¼o_ prostsze. To, co zrobiliÅ›my, to odwrÃ³ciliÅ›my kontrolÄ™! ZmieniliÅ›my odpowiedzialnoÅ›Ä‡ za decydowanie, ktÃ³ry element trafia do nowej tablicy z funkcji `filter` na tÄ™, ktÃ³ra wywoÅ‚uje funkcjÄ™ `filter`. ZauwaÅ¼, Å¼e funkcja `filter` jest nadal przydatnÄ… abstrakcjÄ… sama w sobie, ale jest znacznie bardziej zdolna.

Ale czy poprzednia wersja tej abstrakcji byÅ‚a aÅ¼ tak zÅ‚a? MoÅ¼e nie. Ale poniewaÅ¼ odwrÃ³ciliÅ›my kontrolÄ™, moÅ¼emy teraz obsÅ‚ugiwaÄ‡ znacznie bardziej unikalne przypadki uÅ¼ycia:

```ts
filter(
  [
    { name: 'dog', legs: 4, mammal: true },
    { name: 'dolphin', legs: 0, mammal: true },
    { name: 'eagle', legs: 2, mammal: false },
    { name: 'elephant', legs: 4, mammal: true },
    { name: 'robin', legs: 2, mammal: false },
    { name: 'cat', legs: 4, mammal: true },
    { name: 'salmon', legs: 0, mammal: false },
  ],
  (animal) => animal.legs === 0
)
// [
//   {name: 'dolphin', legs: 0, mammal: true},
//   {name: 'salmon', legs: 0, mammal: false},
// ]
```

WyobraÅº sobie, Å¼e musisz dodaÄ‡ obsÅ‚ugÄ™ tego wczeÅ›niej, przed odwrÃ³ceniem kontroli? To byÅ‚oby po prostu gÅ‚upie...

## [Gorsze API?](#gorsze-api)

JednÄ… z czÄ™stych skarg, ktÃ³re sÅ‚yszÄ™ od ludzi na temat API z odwrÃ³conÄ… kontrolÄ…, ktÃ³re stworzyÅ‚em, jest: "Tak, ale teraz jest trudniejsze w uÅ¼yciu niÅ¼ wczeÅ›niej". WeÅºmy ten przykÅ‚ad:

```ts
// wczeÅ›niej
filter([0, 1, undefined, 2, null, 3, 'four', ''])

// teraz
filter([0, 1, undefined, 2, null, 3, 'four', ''], (el) => el !== null && el !== undefined)
```

Tak, jedno z nich jest wyraÅºnie Å‚atwiejsze w uÅ¼yciu niÅ¼ drugie. Ale oto rzecz dotyczÄ…ca API z odwrÃ³conÄ… kontrolÄ…, moÅ¼esz ich uÅ¼yÄ‡ do ponownej implementacji poprzedniego API i zwykle jest to doÅ›Ä‡ trywialne. Na przykÅ‚ad:

```ts
function filterWithOptions(
  array,
  { filterNull = true, filterUndefined = true, filterZero = false, filterEmptyString = false } = {}
) {
  return filter(
    array,
    (element) =>
      !(
        (filterNull && element === null) ||
        (filterUndefined && element === undefined) ||
        (filterZero && element === 0) ||
        (filterEmptyString && element === '')
      )
  )
}
```

Fajnie, prawda!? WiÄ™c moÅ¼emy budowaÄ‡ abstrakcje na podstawie API z odwrÃ³conÄ… kontrolÄ…, ktÃ³re dajÄ… prostsze API, ktÃ³rych ludzie szukajÄ…. I co wiÄ™cej, jeÅ›li nasze "prostsze" API nie jest wystarczajÄ…ce dla ich przypadku uÅ¼ycia, to mogÄ… uÅ¼yÄ‡ tych samych bloczkÃ³w budulcowych, ktÃ³rych uÅ¼yliÅ›my do zbudowania naszego API wyÅ¼szego poziomu, aby wykonaÄ‡ swoje bardziej zÅ‚oÅ¼one zadanie. Nie muszÄ… prosiÄ‡ nas o dodanie nowej funkcji do `filterWithOptions` i czekaÄ‡, aÅ¼ zostanie to zakoÅ„czone. MajÄ… narzÄ™dzia, ktÃ³rych potrzebujÄ…, aby wysÅ‚aÄ‡ swoje rzeczy, poniewaÅ¼ daliÅ›my im je.

Aha, i dla zabawy:

```ts
function filterByLegCount(array, legCount) {
  return filter(array, (animal) => animal.legs === legCount)
}

filterByLegCount(
  [
    { name: 'dog', legs: 4, mammal: true },
    { name: 'dolphin', legs: 0, mammal: true },
    { name: 'eagle', legs: 2, mammal: false },
    { name: 'elephant', legs: 4, mammal: true },
    { name: 'robin', legs: 2, mammal: false },
    { name: 'cat', legs: 4, mammal: true },
    { name: 'salmon', legs: 0, mammal: false },
  ],
  0
)
// [
//   {name: 'dolphin', legs: 0, mammal: true},
//   {name: 'salmon', legs: 0, mammal: false},
// ]
```

MoÅ¼esz komponowaÄ‡ te rzeczy tak, jak chcesz, aby rozwiÄ…zaÄ‡ wspÃ³lne przypadki uÅ¼ycia, ktÃ³rych potrzebujesz.

## [Ok, ale teraz na serio?](#ok-ale-teraz-na-serio)

OdwrÃ³cenie zaleÅ¼noÅ›ci dziaÅ‚a dla prostego przypadku uÅ¼ycia, ale do czego to jest dobre w prawdziwym Å›wiecie? Prawdopodobnie uÅ¼ywasz API z odwrÃ³conÄ… kontrolÄ… caÅ‚y czas, nie zauwaÅ¼ajÄ…c. Na przykÅ‚ad _faktyczna_ funkcja `Array.prototype.filter` odwraca kontrolÄ™. Tak samo jak funkcja `Array.prototype.map`.

IstniejÄ… rÃ³wnieÅ¼ wzorce, z ktÃ³rymi moÅ¼esz byÄ‡ zaznajomiony, ktÃ³re sÄ… w zasadzie formÄ… odwrÃ³cenia kontroli.

Moje dwa ulubione wzorce to ["Compound Components"](/blog/compound-components-with-react-hooks) i ["State Reducers"](/blog/the-state-reducer-pattern). Oto szybki przykÅ‚ad, jak moÅ¼na ich uÅ¼yÄ‡.

### [Compound Components](#compound-components)

Powiedzmy, Å¼e chcesz zbudowaÄ‡ komponent `Menu`, ktÃ³ry ma przycisk do otwierania menu i listÄ™ elementÃ³w menu do wyÅ›wietlenia po klikniÄ™ciu. NastÄ™pnie, gdy zostanie wybrany element, zostanie wykonana pewna akcja. Powszechnym podejÅ›ciem do tego rodzaju komponentu jest utworzenie propsÃ³w dla kaÅ¼dej z tych rzeczy:

```ts
function App() {
  return (
    <Menu
      buttonContents={
        <>
          Actions <span aria-hidden>â–¾</span>
        </>
      }
      items={[
        { contents: 'Download', onSelect: () => alert('Download') },
        { contents: 'Create a Copy', onSelect: () => alert('Create a Copy') },
        { contents: 'Delete', onSelect: () => alert('Delete') },
      ]}
    />
  )
}
```

DziÄ™ki temu moÅ¼emy dostosowaÄ‡ wiele rzeczy w naszym elemencie Menu. Ale co, jeÅ›li chcielibyÅ›my wstawiÄ‡ liniÄ™ przed elementem menu Delete? Czy musielibyÅ›my dodaÄ‡ opcjÄ™ do tablicy obiektÃ³w elementÃ³w? Na przykÅ‚ad: `precedeWithLine`? O matko. MoÅ¼e mielibyÅ›my specjalny rodzaj elementu menu, ktÃ³ry jest `{contents: <hr />}`. MyÅ›lÄ™, Å¼e to by zadziaÅ‚aÅ‚o, ale wtedy musielibyÅ›my obsÅ‚uÅ¼yÄ‡ przypadek, w ktÃ³rym nie jest dostarczony `onSelect`. I to jest naprawdÄ™ nieporÄ™czne API.

Gdy myÅ›lisz o tym, jak stworzyÄ‡ Å‚adne API dla osÃ³b, ktÃ³re prÃ³bujÄ… robiÄ‡ rzeczy nieco inaczej, zamiast siÄ™gaÄ‡ po instrukcje `if` i operator trÃ³jskÅ‚adniowy (ternary operator), rozwaÅ¼ moÅ¼liwoÅ›Ä‡ odwrÃ³cenia kontroli. W tym przypadku, co jeÅ›li byÅ›my dali odpowiedzialnoÅ›Ä‡Â renderowania uÅ¼ytkownikowi naszych komponentÃ³w? Wykorzystajmy jednÄ… z najwiÄ™kszych zalet Reacta, jakÄ… jest komponowalnoÅ›Ä‡:

```ts
function App() {
  return (
    <Menu>
      <MenuButton>
        Actions <span aria-hidden>â–¾</span>
      </MenuButton>
      <MenuList>
        <MenuItem onSelect={() => alert('Download')}>Download</MenuItem>
        <MenuItem onSelect={() => alert('Copy')}>Create a Copy</MenuItem>
        <MenuItem onSelect={() => alert('Delete')}>Delete</MenuItem>
      </MenuList>
    </Menu>
  )
}
```

KluczowÄ… rzeczÄ… do zauwaÅ¼enia tutaj jest to, Å¼e nie ma stanu widocznego dla uÅ¼ytkownika komponentÃ³w. Stan jest niejawnie wspÃ³Å‚dzielony miÄ™dzy tymi komponentami. To jest gÅ‚Ã³wnÄ… wartoÅ›ciÄ… wzorca komponentÃ³w zÅ‚oÅ¼onych. KorzystajÄ…c z tej moÅ¼liwoÅ›ci, oddaliÅ›my niektÃ³re zadania renderowania uÅ¼ytkownikowi naszych komponentÃ³w, a teraz dodanie dodatkowej linii (lub czegokolwiek innego) jest doÅ›Ä‡ trywialne i intuicyjne. Nie ma dokumentacji API do wyszukiwania, a nie ma dodatkowych funkcji, kodu ani testÃ³w do dodania. DuÅ¼y sukces dla wszystkich.

MoÅ¼esz przeczytaÄ‡ wiÄ™cej na temat tego wzorca [na moim blogu](/blog/compound-components-with-react-hooks). PodziÄ™kowania dla [Ryana Florence](https://twitter.com/ryanflorence), ktÃ³ry mnie tego wzorca nauczyÅ‚.

### [State Reducer](#state-reducer)

Jest to wzorzec, ktÃ³ry wymyÅ›liÅ‚em, aby rozwiÄ…zaÄ‡ problem dostosowywania logiki komponentu. WiÄ™cej na ten temat moÅ¼esz przeczytaÄ‡ w moim poÅ›cie na blogu ["The State Reducer Pattern"](/blog/the-state-reducer-pattern), ale podstawowÄ… ideÄ… jest to, Å¼e miaÅ‚em bibliotekÄ™ wyszukiwania/wpisywania/autouzupeÅ‚niania wejÅ›cia o nazwie `Downshift`, a ktoÅ› budowaÅ‚ wersjÄ™ wielokrotnego wyboru komponentu, wiÄ™c chcieli, aby menu pozostaÅ‚o otwarte nawet po wybraniu elementu.

W `Downshift` mieliÅ›my logikÄ™, ktÃ³ra mÃ³wiÅ‚a, Å¼e powinna zamknÄ…Ä‡ siÄ™, gdy zostanie dokonany wybÃ³r. Osoba potrzebujÄ…ca funkcji zaproponowaÅ‚a dodanie propa o nazwie `closeOnSelection`. OdrzuciÅ‚em to, poniewaÅ¼ byÅ‚em juÅ¼ na tej drodze [apropcalypse](https://twitter.com/gurlcode/status/1002110517094371328) i chciaÅ‚em tego uniknÄ…Ä‡.

Zamiast tego wymyÅ›liÅ‚em API dla osÃ³b, ktÃ³re chcÄ… kontrolowaÄ‡, jak zmiana stanu nastÄ™puje. PomyÅ›l o reduktorze stanu jako o funkcji, ktÃ³ra jest wywoÅ‚ywana za kaÅ¼dym razem, gdy stan komponentu siÄ™ zmienia i daje deweloperowi aplikacji szansÄ™ na zmodyfikowanie zmiany stanu, ktÃ³ra ma siÄ™ wydarzyÄ‡.

Oto przykÅ‚ad tego, co zrobisz, jeÅ›li chcesz, aby Downshift nie zamykaÅ‚ menu po wybraniu elementu przez uÅ¼ytkownika:

```ts
function stateReducer(state, changes) {
  switch (changes.type) {
    case Downshift.stateChangeTypes.keyDownEnter:
    case Downshift.stateChangeTypes.clickItem:
      return {
        ...changes,
        // jesteÅ›my w porzÄ…dku z dowolnymi zmianami, ktÃ³re Downshift chce wprowadziÄ‡
        // z wyjÄ…tkiem tego, Å¼e pozostawimy isOpen i highlightedIndex bez zmian.
        isOpen: state.isOpen,
        highlightedIndex: state.highlightedIndex,
      }
    default:
      return changes
  }
}

// a nastÄ™pnie podczas renderowania komponentu
// <Downshift stateReducer={stateReducer} {...restOfTheProps} />
```

Po dodaniu tego propa dostaliÅ›my ZNACZNIE mniej Å¼Ä…daÅ„ dostosowania komponentu. StaÅ‚ siÄ™ ZNACZNIE bardziej zdolny i o wiele prostszy dla ludzi, aby zrobiÄ‡ z nim cokolwiek chcieli.

### [Render Props](#render-props)

ChciaÅ‚bym tylko krÃ³tko wspomnieÄ‡ o wzorcu [render props](https://reactjs.org/docs/render-props.html), ktÃ³ry jest doskonaÅ‚ym przykÅ‚adem odwrÃ³cenia kontroli, ale nie potrzebujemy go tak czÄ™sto, wiÄ™c nie bÄ™dÄ™ o nich mÃ³wiÄ‡.

[Przeczytaj, dlaczego juÅ¼ nie potrzebujemy Render Props tak czÄ™sto](/blog/react-hooks-whats-going-to-happen-to-render-props)

## [SÅ‚owo ostrzeÅ¼enia](#slowo-ostrzezenia)

OdwrÃ³cenie kontroli jest fantastycznym sposobem na obejÅ›cie problemu dokonywania nieprawidÅ‚owych zaÅ‚oÅ¼eÅ„ dotyczÄ…cych przyszÅ‚ych przypadkÃ³w uÅ¼ycia naszego kodu wielokrotnego uÅ¼ytku. Ale zanim pÃ³jdziesz, chcÄ™ ci daÄ‡ kilka rad. WrÃ³Ä‡my na chwilÄ™ do naszego wymyÅ›lonego przykÅ‚adu:

```ts
// udawajmy Å¼e Array.prototype.filter nie istnieje
function filter(array) {
  let newArray = []
  for (let index = 0; index < array.length; index++) {
    const element = array[index]
    if (element !== null && element !== undefined) {
      newArray[newArray.length] = element
    }
  }
  return newArray
}

// przypadki uÅ¼ycia:

filter([0, 1, undefined, 2, null, 3, 'four', ''])
// [0, 1, 2, 3, 'four', '']
```

Co, jeÅ›li to wszystko, czego kiedykolwiek potrzebowaliÅ›my, aby `filter` dziaÅ‚aÅ‚ i nigdy nie napotkaliÅ›my sytuacji, w ktÃ³rej potrzebowaliÅ›my filtrowaÄ‡ cokolwiek innego niÅ¼ `null` i `undefined`? W takim przypadku dodanie odwrÃ³cenia kontroli dla pojedynczego przypadku uÅ¼ycia sprawiÅ‚oby, Å¼e kod byÅ‚by bardziej skomplikowany i nie zapewniÅ‚by wiele wartoÅ›ci.

Jak w przypadku kaÅ¼dej abstrakcji, proszÄ™ o rozwagÄ™ i zastosowanie zasady [AHA Programming](/blog/aha-programming) i unikanie pochopnych abstrakcji!

## [Podsumowanie](#podsumowanie)

Mam nadziejÄ™, Å¼e to ci pomoÅ¼e. PokazaÅ‚em Ci kilka wzorcÃ³w w ekosystemie React, ktÃ³re wykorzystujÄ… koncepcjÄ™ odwrÃ³cenia kontroli. IstniejÄ… inne, a koncepcja ta dotyczy nie tylko React (jak widzieliÅ›my na przykÅ‚adzie `filter`). NastÄ™pnym razem, gdy dodasz kolejne instrukcje `if` do funkcji `coreBusinessLogic` swojej aplikacji, rozwaÅ¼, jak moÅ¼esz odwrÃ³ciÄ‡ kontrolÄ™ i przenieÅ›Ä‡ logikÄ™ do miejsca, w ktÃ³rym jest uÅ¼ywana (lub jeÅ›li jest uÅ¼ywana w wielu miejscach, moÅ¼esz zbudowaÄ‡ bardziej dopasowanÄ… do tego konkretnego przypadku uÅ¼ycia abstrakcjÄ™).

JeÅ›li chcesz pobawiÄ‡ siÄ™ przykÅ‚adem w tym poÅ›cie na blogu, zapraszam tutaj:

[![Edytuj odwrÃ³cenie kontroli](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/inversion-of-control-qunm8?fontsize=14&hidenavigation=1&theme=dark)

Powodzenia!

P.S. JeÅ›li podobaÅ‚ Ci siÄ™ ten post na blogu, prawdopodobnie spodoba Ci siÄ™ ta rozmowa:

[![Simply React](https://markdown-videos-api.jorgenkh.no/youtube/AiJ8tRRH0f8)](https://www.youtube.com/watch?v=AiJ8tRRH0f8&list=PLV5CVI1eNcJgNqzNwcs4UKrlJdhfDjshf&t=7s)
